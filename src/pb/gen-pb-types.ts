import { writeFile, readFile } from "node:fs/promises";
import { checkAndCreateNestsedDir, runCommand } from "./fs";

const DEFAULT_PB_FILES_DIR = "./src/lib/pb";
// const CUSTOM_DB_TYPES_PATH = `${DEFAULT_PB_FILES_DIR}/pb-types.ts`;
const DEFAULT_CUSTOM_DB_TYPES_PATH = `${DEFAULT_PB_FILES_DIR}/custom-pb-types.ts`;
const CHUNKED_TYPES_OUTPUT_DIR = `${DEFAULT_PB_FILES_DIR}//database.ts`;

export async function getPBType() {
  const PB_ADMIN_EMAIL = process.env.PB_ADMIN_EMAIL ?? "admin1@email.com";
  const PB_ADMIN_PASSWORD = process.env.PB_ADMIN_PASSWORD ?? "admin1@email.com";

  const commands = [
    "npx",
    "typed-pocketbase",
    "--email",
    PB_ADMIN_EMAIL,
    "--password",
    PB_ADMIN_PASSWORD,
  ];
  console.log(" ================ running command =============== ", commands);
  const output = await runCommand(commands.join(" "));
  return output;
}

export async function getCustomTypes() {
  try {
    const custom_db_types_string = await readFile(DEFAULT_CUSTOM_DB_TYPES_PATH, "utf-8");
    let extracted_custom_db_types = "";
    const extracted_custom_db_types_array: {
      target_interface: string;
      field: string;
      new_custom_type: string;
    }[] = [];
    const custom_db_types_lines = custom_db_types_string.split("\n");
    //   const custom_type_start = custom_db_types_lines.findIndex((line) =>line.includes("custom_db_types"));
    for (const [index, line] of custom_db_types_lines.entries()) {
      if (line.includes("=== start of custom type ===")) {
        const custom_block_hint = custom_db_types_lines[index + 1].trim().split(".");

        const sub_custom_db_types_lines = custom_db_types_lines.slice(index);
        // console.log("= sub custom type lines ", sub_custom_db_types_lines);
        const custom_block_end = sub_custom_db_types_lines.findIndex((line) =>
          line.includes("=== end of custom type ===")
        );
        //   console.log("= custom block end ", custom_block_end);
        const custom_type_in_block = sub_custom_db_types_lines.slice(2, custom_block_end);
        extracted_custom_db_types += `${custom_type_in_block.join("\n")}\n`;
        const target_interface_prefix = custom_block_hint[0].replace("//", "").trim();
        extracted_custom_db_types_array.push({
          target_interface: `${target_interface_prefix}Create`,
          field: `${custom_block_hint[2]}`,
          new_custom_type: custom_block_hint[1],
        });
        extracted_custom_db_types_array.push({
          target_interface: `${target_interface_prefix}Update`,
          field: `${custom_block_hint[2]}`,
          new_custom_type: custom_block_hint[1],
        });
        extracted_custom_db_types_array.push({
          target_interface: `${target_interface_prefix}Response`,
          field: `${custom_block_hint[2]}`,
          new_custom_type: custom_block_hint[1],
        });
      }
    }
    return {
      extracted_custom_db_types,
      extracted_custom_db_types_array,
    };
  } catch (error: any) {
    if (error.code === "ENOENT") {
      // console.log(" ===  custom db types Error code ====  ", error.code);
      await checkAndCreateNestsedDir(DEFAULT_PB_FILES_DIR);
      await writeFile(DEFAULT_CUSTOM_DB_TYPES_PATH, "const uwu = {  }", "utf-8");
      // console.log(`Created ${CUSTOM_DB_TYPES_PATH} with default values`);
      return { extracted_custom_db_types: "", extracted_custom_db_types_array: [] };
    } else {
      throw error;
    }
  }
}

export async function modifyAndInjectCustomSTypes(content: string) {
  const { extracted_custom_db_types, extracted_custom_db_types_array } = await getCustomTypes();
  const content_array = content.split("\n");
  for (const [
    idx,
    { target_interface, field, new_custom_type },
  ] of extracted_custom_db_types_array.entries()) {
    for (const [index, target] of content_array.entries()) {
      if (target.includes(target_interface)) {
        const target_index = content_array.findIndex((line, idx) => {
          return line.includes(field) && idx > index;
        });

        if (target_index && target_index > 0) {
          content_array.splice(target_index, 1, `\t${field}?: ${new_custom_type}`);
        }
      }
    }
  }
  const new_content_string = `${extracted_custom_db_types}\n${content_array.join("\n")}`;
  // console.log(" === content after  ==== ",new_content_string)
  return new_content_string;
}

// cli util to filter out the types generated by typed pocektbase by the provided collection
export async function filterByCollection(schema_string: string, collection = "") {
  // if (!collection) {
  //   throw new Error("Please provide a collection name");
  // }
  try {
    let text_output = "";
    let currentBlock: string | null = null;
    let first_block_index = 0;
    let current_block_indexes = [0, 0];
    const all_block_indexes: { [key: string]: number[] } = {};

    // const file_string = await readFile(TYPES_OUTPUT_PATH, "utf-8");
    // const file_string = await getPBType();
    const lines = schema_string.split("\n");
    for (const [index, line] of lines.entries()) {
      if (currentBlock) {
        // mark the end current block if at the end of the file
        if (lines.length - 1 === index) {
          current_block_indexes[1] = index;
          all_block_indexes[currentBlock] = [...current_block_indexes];
        }
      }
      if (line.startsWith("// ===== ")) {
        const current_block_name = line.split("=====")[1].trim();
        // currentBlck is not null after the first // ===== encount eredor a new block
        if (currentBlock) {
          // current block is not the same as the current block name
          if (currentBlock !== current_block_name) {
            // mark where the currennt block index ends at
            current_block_indexes[1] = index;
            // save the current block index to the all_block_indexes
            all_block_indexes[currentBlock] = [...current_block_indexes];
          }
          //   nullify the current block name to start the new one
          currentBlock = null;
        }
        // current block is null after the first // ===== encount eredor a new block
        if (!currentBlock) {
          // mark where the first // ===== block index is encountered ,this will be used to determine where the glbal/shared types end
          if (Object.entries(all_block_indexes).length === 0) {
            first_block_index = index;
          }
          // mark where the currennt block index starts at
          current_block_indexes[0] = index;
          //   set the current block name
          currentBlock = current_block_name;
        }
      }
    }
    //  add init types ( shared pocketbase types )
    const init_types = lines.slice(0, first_block_index);
    text_output = init_types.join("\n");
    //  Main types section
    for (const [key, value] of Object.entries(all_block_indexes)) {
      // filter only for specified collection
      if (!key.includes(collection)) continue;
      const selected_lines = lines.slice(value[0], value[1]);
      selected_lines.splice(0, 1, `// ==== start of ${key} block =====\n`);
      selected_lines.push(`// ==== end of ${key} block =====\n`);
      const data = selected_lines.join("\n");
      text_output += `${data}\n`;
    }
    //  add the final schema block
    const schema_block = all_block_indexes.Schema;

    // filter only for specified collection
    if (schema_block) {
      const schema_lines = lines.slice(schema_block[0], schema_block[1]);

      // final schema looks like this
      // export type Schema = {
      //   _mfas: MfasCollection;
      //   _otps: OtpsCollection;
      //   _externalAuths: ExternalAuthsCollection;
      //   _authOrigins: AuthOriginsCollection;
      //   _superusers: SuperusersCollection;
      //   users: UsersCollection;
      //   posts: PostsCollection;
      //   comments: CommentsCollection;
      // };

      const filtered_schema_lines = [];

      for (const line of schema_lines) {
        if (line.includes(collection)) {
          filtered_schema_lines.push(line);
        } else if (line.includes("{") || line.includes("}")) {
          filtered_schema_lines.push(line);
        }
      }
      // initla parsing adds a schema block at the end of the file that will be duplicated if not removed
      const text_output_without_init_schema_block = text_output.split(
        "// ==== start of Schema block ====="
      )[0];
      text_output = text_output_without_init_schema_block + "\n" + filtered_schema_lines.join("\n");
      // console.log(" === text_output after === ",text_output.slice(text_output.length - 1000))
    }

    // insert custon types in src\lib\pb\custom-db-types.ts
    // ensure we have custom types in src\lib\pb\custom-db-types.ts
    const modified_custom_db_types = await modifyAndInjectCustomSTypes(text_output);

    await writeFile(CHUNKED_TYPES_OUTPUT_DIR, modified_custom_db_types, "utf-8");
    return { text_output, all_block_indexes, first_block_index, modified_custom_db_types };
  } catch (error) {
    // biome-ignore lint/complexity/noUselessCatch: <explanation>
    throw error;
  }
}

async function main() {
  const { modified_custom_db_types } = await filterByCollection(await getPBType(), "users");
  // console.log("modified_custom_db_types", modified_custom_db_types);
  // const modified_custom_db_types = await modifyAndInjectCustomSTypes(text_output);
  // console.log("text_output", text_output);
  // console.log("all_block_indexes", all_block_indexes);
  // console.log("first_block_index", first_block_index);
  // console.log("modified_custom_db_types", modified_custom_db_types);
  // await writeFile(resolve(CUSTOM_DB_TYPES_PATH), "const uwu = {  }", "utf-8");
  // await writeFile(CHUNKED_TYPES_OUTPUT_DIR, text_output, "utf-8");
}
main()
  .then((res) => {
    console.log("=== success === ");
  })
  .catch((err) => {
    console.log("=== error === ", err);
  });

// filterByCollection()
//   .then((res) => {
//     console.log("===== succesfull types generation ==== ");
//   })
//   .catch((err) => {
//     console.log("===== error types generation ==== ", err);
//   });
